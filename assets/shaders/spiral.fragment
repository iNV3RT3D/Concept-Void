#version 300 es
precision lowp float;
out vec4 fragColor;

uniform vec3 iResolution;
uniform float iTime;
uniform float iFrame;
uniform vec4 iMouse;

#define UV_ORIGIN 0.5
#define ZOOM 1.0
#define SPEED -24.0
#define SCROLL -0.05
#define TWIST 720.0
#define CLAMP01(T) clamp((T), 0.0, 1.0)

// fast high-quality hash https://www.shadertoy.com/view/wfVczm
uint hash(uvec2 key, uint seed) {
    uvec2 k = key;
    k *= 0x27d4eb2fu;
    k ^= k >> 16;
    k *= 0x85ebca77u;
    uint h = seed;
    h ^= k.x;
    h ^= h >> 16;
    h *= 0x9e3779b1u;
    h ^= k.y;
    h ^= h >> 16;
    h *= 0x9e3779b1u;
    h ^= h >> 16;
    h *= 0xed5ad4bbu;
    h ^= h >> 16;
    return h;
}

// generates a distinct seed for each octave
// that will behave like a 3rd coordinate
// when mixed into the final hash
uint hash(uint key, uint seed) {
    uint k = key;
    k *= 0x27d4eb2fu;
    k ^= k >> 16;
    k *= 0x85ebca77u;
    uint h = seed;
    h ^= k;
    h ^= h >> 16;
    h *= 0x9e3779b1u;
    return h;
}

vec2 gradient(uint h) {
    const vec2 gradients[4] = vec2[4](
        vec2(1.0, 1.0), vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(-1.0, -1.0)
    );
    return gradients[int(h & 3u)];
}

float interpolate(float value1, float value2, float value3, float value4, vec2 t) {
    return mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y);
}

vec2 fade(vec2 t) {
    // 6t^5 - 15t^4 + 10t^3
	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

float perlinNoise(vec2 position, uint seed) {
    vec2 floorPosition = floor(position);
    vec2 fractPosition = position - floorPosition;
    uvec2 cellCoordinates = uvec2(ivec2(floorPosition));
    float value1 = dot(gradient(hash(cellCoordinates, seed)), fractPosition);
    float value2 = dot(gradient(hash(cellCoordinates + uvec2(1, 0), seed)), fractPosition - vec2(1.0, 0.0));
    float value3 = dot(gradient(hash(cellCoordinates + uvec2(0, 1), seed)), fractPosition - vec2(0.0, 1.0));
    float value4 = dot(gradient(hash(cellCoordinates + uvec2(1, 1), seed)), fractPosition - vec2(1.0, 1.0));
    return interpolate(value1, value2, value3, value4, fade(fractPosition));
}

float perlinNoise(vec2 position, int octaveCount, float persistence, float lacunarity, uint seed) {
    float value = 0.0;
    float amplitude = 1.0;
    for (int i = 0; i < octaveCount; i++) {
        uint s = hash(uint(i), seed);
        value += perlinNoise(position, s) * amplitude;
        amplitude *= persistence;
        position *= lacunarity;
    }
    return value;
}

vec3 ColorRamp_Linear(in float T, vec4 A, in vec4 B, in vec4 C, in vec4 D)
{
    // Distances =
    float AB = B.w-A.w;
    float BC = C.w-B.w;
    float CD = D.w-C.w;

    // Intervales :
    float iAB = CLAMP01((T-A.w)/AB);
    float iBC = CLAMP01((T-B.w)/BC);
    float iCD = CLAMP01((T-C.w)/CD);

    // PondÃ©rations :
    float pA = 1.0-iAB;
    float pB = iAB-iBC;
    float pC = iBC-iCD;
    float pD = iCD;

    return pA*A.xyz + pB*B.xyz + pC*C.xyz + pD*D.xyz;
}

const float PI = 3.14;

mat2 rotationMatrix(float angle)
{
    angle *= PI / 180.0;
    float sine = sin(angle), cosine = cos(angle);
    return mat2( cosine, -sine,
                 sine,    cosine );
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = (fragCoord - UV_ORIGIN * iResolution.xy)/iResolution.xy / 2.0;
    float dist = length(uv);
    uv *= rotationMatrix( SPEED * iTime + dist * TWIST ) * ZOOM;

    float pixelRot = degrees(atan(uv.x, uv.y)) + 180.0;
    float smoothRot = pixelRot > 180.0 ? 360.0 - pixelRot : pixelRot;

    uint seed = 42u;
    float noise = perlinNoise(vec2(dist + iTime * SCROLL, smoothRot/180.0) * 0.25, 5, 0.6, 5.0, seed);

    vec3 col = ColorRamp_Linear(dist*6.0+(noise*0.5),
        vec4(1.0,0.0,1.0,0.45),
        vec4(0.5,0.0,1.0,0.5),
        vec4(0.5,0.0,0.7,0.7),
        vec4(0.0,0.0,0.0,1.0)
    );

    float alpha = ColorRamp_Linear(dist*5.0+(noise/2.0),
        vec4(1.0,0.0,0.0,0.3),
        vec4(1.0,0.0,0.0,0.4),
        vec4(1.0,0.0,0.0,0.6),
        vec4(0.0,0.0,0.0,1.0)
    ).x;

    const float eventRadius = 0.3;

    col = ColorRamp_Linear(dist*5.0,
        vec4(0.0,0.0,0.0,0.009+eventRadius),
        vec4(1.0,1.0,1.0,0.01+eventRadius),
        vec4(1.0,1.0,1.0,0.015+eventRadius),
        vec4(col,0.08+eventRadius)
    );


    // Output to screen
    fragColor = vec4(col, alpha);
}

void main() {
    mainImage(fragColor,gl_FragCoord.xy);
}