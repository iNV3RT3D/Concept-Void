#version 300 es
precision highp float;
out vec4 fragColor;

uniform vec3 iResolution;
uniform float iTime;
uniform float iFrame;
uniform vec4 iMouse;

#define UV_ORIGIN 0.5
#define ZOOM 1.0
#define SPEED -24.0
#define SCROLL -0.05
#define TWIST 720.0
#define CLAMP01(T) clamp((T), 0.0, 1.0)

// fast high-quality hash https://www.shadertoy.com/view/wfVczm
uint hash(uvec3 key, uint seed) {
    uvec3 k = key;
    k *= 0x27d4eb2fu;
    k ^= k >> 16;
    k *= 0x85ebca77u;
    uint h = seed;
    h ^= k.x;
    h ^= h >> 16;
    h *= 0x9e3779b1u;
    h ^= k.y;
    h ^= h >> 16;
    h *= 0x9e3779b1u;
    h ^= k.z;
    h ^= h >> 16;
    h *= 0x9e3779b1u;
    h ^= h >> 16;
    h *= 0xed5ad4bbu;
    h ^= h >> 16;
    return h;
}

// generates a distinct seed for each octave
// that will behave like a 4th coordinate
// when mixed into the final hash
uint hash(uint key, uint seed) {
    uint k = key;
    k *= 0x27d4eb2fu;
    k ^= k >> 16;
    k *= 0x85ebca77u;
    uint h = seed;
    h ^= k;
    h ^= h >> 16;
    h *= 0x9e3779b1u;
    return h;
}

vec3 gradient(uint h) {
    const vec3 gradients[12] = vec3[12](
        vec3(1, 1, 0), vec3(-1, 1, 0), vec3(1, -1, 0), vec3(-1, -1, 0),
        vec3(1, 0, 1), vec3(-1, 0, 1), vec3(1, 0, -1), vec3(-1, 0, -1),
        vec3(0, 1, 1), vec3(0, -1, 1), vec3(0, 1, -1), vec3(0, -1, -1)
    );
    return gradients[int(h % 12u)];
}

float interpolate(float value1, float value2, float value3, float value4, float value5, float value6, float value7, float value8, vec3 t) {
    return mix(
        mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y),
        mix(mix(value5, value6, t.x), mix(value7, value8, t.x), t.y),
        t.z
    );
}

vec3 fade(vec3 t) {
    // 6t^5 - 15t^4 + 10t^3
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

float perlinNoise(vec3 position, uint seed) {
    vec3 floorPosition = floor(position);
    vec3 fractPosition = position - floorPosition;
    uvec3 cellCoordinates = uvec3(ivec3(floorPosition));
    float value1 = dot(gradient(hash(cellCoordinates, seed)), fractPosition);
    float value2 = dot(gradient(hash(cellCoordinates + uvec3(1, 0, 0), seed)), fractPosition - vec3(1, 0, 0));
    float value3 = dot(gradient(hash(cellCoordinates + uvec3(0, 1, 0), seed)), fractPosition - vec3(0, 1, 0));
    float value4 = dot(gradient(hash(cellCoordinates + uvec3(1, 1, 0), seed)), fractPosition - vec3(1, 1, 0));
    float value5 = dot(gradient(hash(cellCoordinates + uvec3(0, 0, 1), seed)), fractPosition - vec3(0, 0, 1));
    float value6 = dot(gradient(hash(cellCoordinates + uvec3(1, 0, 1), seed)), fractPosition - vec3(1, 0, 1));
    float value7 = dot(gradient(hash(cellCoordinates + uvec3(0, 1, 1), seed)), fractPosition - vec3(0, 1, 1));
    float value8 = dot(gradient(hash(cellCoordinates + uvec3(1, 1, 1), seed)), fractPosition - vec3(1, 1, 1));
    return interpolate(value1, value2, value3, value4, value5, value6, value7, value8, fade(fractPosition));
}

float perlinNoise(vec3 position, int octaveCount, float persistence, float lacunarity, uint seed) {
    float value = 0.0;
    float amplitude = 1.0;
    for (int i = 0; i < octaveCount; i++) {
        uint s = hash(uint(i), seed);
        value += perlinNoise(position, s) * amplitude;
        amplitude *= persistence;
        position *= lacunarity;
    }
    return value;
}

vec3 ColorRamp_Linear(in float T, vec4 A, in vec4 B, in vec4 C, in vec4 D)
{
    // Distances =
    float AB = B.w-A.w;
    float BC = C.w-B.w;
    float CD = D.w-C.w;

    // Intervales :
    float iAB = CLAMP01((T-A.w)/AB);
    float iBC = CLAMP01((T-B.w)/BC);
    float iCD = CLAMP01((T-C.w)/CD);

    // PondÃ©rations :
    float pA = 1.0-iAB;
    float pB = iAB-iBC;
    float pC = iBC-iCD;
    float pD = iCD;

    return pA*A.xyz + pB*B.xyz + pC*C.xyz + pD*D.xyz;
}

const float PI = 3.14;

mat2 rotationMatrix(float angle)
{
    angle *= PI / 180.0;
    float sine = sin(angle), cosine = cos(angle);
    return mat2( cosine, -sine,
                 sine,    cosine );
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = (fragCoord - UV_ORIGIN * iResolution.xy)/iResolution.xy / 2.0;
    float dist = length(uv);
    uv *= rotationMatrix( SPEED * iTime + dist * TWIST ) * ZOOM;

    float pixelRot = degrees(atan(uv.x, uv.y)) + 180.0;
    float smoothRot = pixelRot > 180.0 ? 360.0 - pixelRot : pixelRot;

    uint seed = 42u;
    float noise = perlinNoise(vec3(dist + iTime * SCROLL, smoothRot/180.0, 0.0) * 0.25, 5, 0.6, 5.0, seed);

    vec3 col = ColorRamp_Linear(dist*6.0+(noise*0.5),
        vec4(1.0,0.0,1.0,0.45),
        vec4(0.5,0.0,1.0,0.5),
        vec4(0.5,0.0,0.7,0.7),
        vec4(0.0,0.0,0.0,1.0)
    );

    float alpha = ColorRamp_Linear(dist*5.0+(noise/2.0),
        vec4(1.0,0.0,0.0,0.3),
        vec4(1.0,0.0,0.0,0.4),
        vec4(1.0,0.0,0.0,0.6),
        vec4(0.0,0.0,0.0,1.0)
    ).x;

    const float eventRadius = 0.3;

    col = ColorRamp_Linear(dist*5.0,
        vec4(0.0,0.0,0.0,0.009+eventRadius),
        vec4(1.0,1.0,1.0,0.01+eventRadius),
        vec4(1.0,1.0,1.0,0.015+eventRadius),
        vec4(col,0.08+eventRadius)
    );


    // Output to screen
    fragColor = vec4(col, alpha);
}

void main() {
    mainImage(fragColor,gl_FragCoord.xy);
}